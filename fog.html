<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Sis Silme Efekti</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            position: relative;
        }

        canvas {
            border: 4px solid #334155;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            touch-action: none;
            display: block;
            max-width: 100%;
            height: auto;
        }

        .reset-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reset-btn:hover {
            transform: scale(1.1) rotate(90deg);
            background: white;
        }

        .reset-btn svg {
            width: 24px;
            height: 24px;
            stroke: #1e293b;
            stroke-width: 2;
            fill: none;
        }

        .info {
            text-align: center;
            margin-top: 30px;
            color: white;
        }

        .info h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .info p {
            font-size: 1.2em;
            color: #cbd5e1;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="fogCanvas" width="800" height="600"></canvas>
        <button class="reset-btn" onclick="resetFog()" title="Sisi Sƒ±fƒ±rla">
            <svg viewBox="0 0 24 24">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        </button>
    </div>

    <div class="info">
        <h1>WebGL Sis Silme Efekti</h1>
        <p>Fareyle veya dokunarak sisi silin! üå´Ô∏è</p>
    </div>

    <script>
        const canvas = document.getElementById('fogCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL desteklenmiyor!');
        }

        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;

            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_texCoord;
            }
        `;

        // Fragment shader
        const fragmentShaderSource = `
            precision mediump float;
            uniform sampler2D u_fogTexture;
            varying vec2 v_texCoord;

            void main() {
                float fogValue = texture2D(u_fogTexture, v_texCoord).r;

                // Sis rengi (beyaz-gri)
                vec3 fogColor = vec3(0.9, 0.9, 0.92);

                // Arka plan rengi (mavi tonlarƒ± - gradient)
                vec3 bgColor = vec3(0.2 + v_texCoord.x * 0.3, 0.3 + v_texCoord.y * 0.2, 0.5);

                // Sis deƒüerine g√∂re karƒ±≈ütƒ±r
                vec3 color = mix(bgColor, fogColor, fogValue);

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Shader olu≈üturma fonksiyonu
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader derlenirken hata:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // Program olu≈üturma
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program olu≈üturulurken hata:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Tam ekran quad i√ßin vertexler
        const positions = new Float32Array([
            -1, -1,  0, 1,
             1, -1,  1, 1,
            -1,  1,  0, 0,
             1,  1,  1, 0,
        ]);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');

        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);

        gl.enableVertexAttribArray(texCoordLocation);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 16, 8);

        // Sis texture'ƒ± olu≈ütur
        const width = canvas.width;
        const height = canvas.height;
        let fogData = new Uint8Array(width * height);

        // Ba≈ülangƒ±√ßta t√ºm ekranƒ± sisle kapla
        for (let i = 0; i < fogData.length; i++) {
            fogData[i] = 255;
        }

        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, fogData);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        // Render loop
        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }

        render();

        // Sis silme fonksiyonu
        let isDrawing = false;

        function wipeFog(x, y) {
            const rect = canvas.getBoundingClientRect();
            const pixelX = Math.floor((x - rect.left) * (canvas.width / rect.width));
            const pixelY = Math.floor((y - rect.top) * (canvas.height / rect.height));

            // Fƒ±r√ßa boyutu
            const brushSize = 30;

            for (let dy = -brushSize; dy <= brushSize; dy++) {
                for (let dx = -brushSize; dx <= brushSize; dx++) {
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= brushSize) {
                        const px = pixelX + dx;
                        const py = pixelY + dy;

                        if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                            const index = py * canvas.width + px;

                            // Yumu≈üak silme efekti
                            const falloff = 1 - (distance / brushSize);
                            const reduction = Math.floor(falloff * 180);
                            fogData[index] = Math.max(0, fogData[index] - reduction);
                        }
                    }
                }
            }

            // Texture'ƒ± g√ºncelle
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, canvas.width, canvas.height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, fogData);
        }

        // Mouse olaylarƒ±
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            wipeFog(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                wipeFog(e.clientX, e.clientY);
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Touch olaylarƒ±
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            const touch = e.touches[0];
            wipeFog(touch.clientX, touch.clientY);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDrawing) {
                const touch = e.touches[0];
                wipeFog(touch.clientX, touch.clientY);
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDrawing = false;
        });

        // Sƒ±fƒ±rlama fonksiyonu
        function resetFog() {
            for (let i = 0; i < fogData.length; i++) {
                fogData[i] = 255;
            }

            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, canvas.width, canvas.height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, fogData);
        }
    </script>
</body>
</html>
